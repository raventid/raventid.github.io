<head>
    <link rel="stylesheet" href="../assets/styles.css">
</head>

<body>
<h1>Provers. What are they and why you might need one?</h1>

In this article I would list some of proof assitants and theorem provers and will try to explain why someone might be interested in trying one of them.

<ul>
  <li>Coq</li>
  <li>Agda</li>
  <li>Idris</li>
  <li>ATS</li>
  <li>Arend</li>
  <li>Isabell</li>
  <li>LEAN</li>
  <li>F*</li>
  <li>Z3 Theorem Prover</li>
</ul>

<p>
  When you think about proving your code is correct you can right a better code. It's like with Rust. When you have a lot of Rust experience you are starting to think in terms of moving/borrowing/lifetimes when you are writing C++ or C code. Provers affect your way of thinking about the programm and things like totality, correctness and many more. In the same time writing even simple proofs might take a lot of time, so it is doubtfull that you want to do it in the same time you write code.
</p>

<p>
  Do we need any form of verification when we are writing some buiseness code? I mean in healthcare, travel logistics, CRM/ERP, you name it. Should we verify login form? Dashboard view? Any other thing?

  HERE I'M BRINGING THE DIFFERENCE BETWEEN TLA+ and LEAN and try to explain what are they
</p>

<div>
  <h3>Coq</h3>
  <p>
    Most widely used and established technology. Has a lot of great literature dedicated to it. (Link logical foundation)
  </p>
  <p>
    <code>
      Theorem plus_O_n : forall n : nat, 0 + n = n.
      Proof.
        intros n. simpl. reflexivity.  Qed.
    </code>
  </p>
  <p>
      Curry-Howard correspondence
  </p>
</div>

<div>
  <h3>Agda</h3>
  <p>Popular prover developed after Haskell with lazyness in mind. Also has a great tutorial and you would find this usefull if you already have some Haskell knowledge</p>
</div>

<div>
  <h3>Idris</h3>
  <p>First language which is trying to find a practical application of dependent types. Could be used as a prover, but more a practical language with dependent types</p>
</div>

<div>
  <h3>ATS</h3>
  <p>Most esoteric language among all of the contenders. Contains proof-language, language with dependent types and refinement types and many more tricks for low-level programming. You can write type-safe malloc and free with it and do type-safe pointer arithmetic. We'll take a closer look at ATS later in other articles too.</p>
</div>

<div>
  <h3>Arend</h3>
  <p>Prover developed by JetBrains research. Based on HOTT approach and gives you a few intereting tricks you can use + perfect IDE to work in</p>
</div>

<div>
  <h3>Isabell</h3>
  <p>Very practical prover. Not hyped, but people just silently do the real stuff with it. (Here gonna be the link). Also this is the only prover here which is not using dependent types and it makes it extra interesting to take a look what alternative approach do they employ</p>
  <p>Real-world applications of Isabell, as an example you can take a look at se4 operating system.</p>
</div>

<div>
  <h3>LEAN</h3>
  <p>Prover developed by Microsoft Research as a response to Coq quirks. Has a very nice intro tutorial and VS Code plugin.</p>
</div>

<div>
  <h3>F*</h3>
  <p>One more contender by Microsoft Research. We want stop here, but F* has been used to verify real software not so long time ago (link to network stack)</p>
</div>

<div>
  <h3>Z3 Theorem Prover</h3>
  <p>

  </p>
</div>


</body>
